#!/usr/bin/python3
from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageChops
import argparse
import os
import shutil
import subprocess
import sys
import time

def get_monitors():
    import ctypes
    import ctypes.util

    def load_library(name):
        path = ctypes.util.find_library(name)
        if not path:
            raise ImportError('Could not load ' + name)
        return ctypes.cdll.LoadLibrary(path)

    class XineramaScreenInfo(ctypes.Structure):
        _fields_ = [
            ('screen_number', ctypes.c_int),
            ('x', ctypes.c_short),
            ('y', ctypes.c_short),
            ('width', ctypes.c_short),
            ('height', ctypes.c_short),
        ]

    xlib = load_library('X11')
    xlib.XOpenDisplay.argtypes = [ctypes.c_char_p]
    xlib.XOpenDisplay.restype = ctypes.POINTER(ctypes.c_void_p)
    d = xlib.XOpenDisplay(b'')
    if not d:
        raise Exception('Could not open display')

    xinerama = load_library('Xinerama')
    if not xinerama.XineramaIsActive(d):
        raise Exception('Xinerama is not active')

    number = ctypes.c_int()
    xinerama.XineramaQueryScreens.restype = ctypes.POINTER(XineramaScreenInfo)
    infos = xinerama.XineramaQueryScreens(d, ctypes.byref(number))
    infos = ctypes.cast(infos, ctypes.POINTER(XineramaScreenInfo * number.value)).contents

    return infos

def cover_or_fit(img, size_dst, quality, cover=False):
    ratio_src = img.size[0] / img.size[1]
    ratio_dst = size_dst[0] / size_dst[1]
    if (ratio_dst > ratio_src) == cover:
        return img.resize((size_dst[0], int(size_dst[0] // ratio_src)), quality)
    else:
        return img.resize((int(size_dst[1] * ratio_src), size_dst[1]), quality)

def cover(img, size_dst, quality=Image.ANTIALIAS):
    return cover_or_fit(img, size_dst, quality, cover=True)

def fit(img, size_dst, quality=Image.ANTIALIAS):
    return cover_or_fit(img, size_dst, quality, cover=False)


class WallpaperChanger(object):
    def __init__(self):
        self.monitors = dict((i + 1, m) for i, m in enumerate(get_monitors()))

    def validate_monitor_number(self, number):
        if number not in self.monitors:
            raise RuntimeError('Monitor number out of range')

    def get_path(self, number):
        return os.path.expanduser('~/.wallpaper%d' % number)

    def get_temp_path(self, number=0):
        return os.path.expanduser('~/.wallpaper%d-tmp' % number)

    def set(self, args):
        self.validate_monitor_number(args.monitor)
        monitor_size = (self.monitors[args.monitor].width, self.monitors[args.monitor].height)

        target_img = Image.new('RGB', monitor_size, args.color)

        if os.path.exists(args.path):
            source_img = Image.open(args.path)
        else:
            raise RuntimeError(args.path + ' does not exist')

        if args.scale == 'fit' or args.scale == None:
            source_img = fit(source_img, monitor_size)
        elif args.scale == 'cover':
            source_img = cover(source_img, monitor_size)

        target_position = tuple((monitor_size[i] - source_img.size[i]) // 2 for i in (0,1))

        target_path = self.get_path(args.monitor)
        if args.preview:
            target_path = self.get_temp_path()

        target_img.paste(source_img, target_position)
        target_img.save(target_path, 'PNG')

        if args.preview:
            paths = [(self.get_path(m), target_path)[m == args.monitor] for m in self.monitors.keys()]
            self.render(paths)
            time.sleep(1)
        self.refresh()

    def swap(self, args):
        if args.first_monitor == args.second_monitor:
            return

        self.validate_monitor_number(args.first_monitor)
        self.validate_monitor_number(args.second_monitor)

        temp_path = self.get_temp_path()
        os.rename(self.get_path(args.second_monitor), temp_path)
        os.rename(self.get_path(args.first_monitor), self.get_path(args.second_monitor))
        os.rename(temp_path, self.get_path(args.first_monitor))
        self.refresh()

    def identify(self, args):
        font = ImageFont.truetype('arial.ttf', 200, encoding='unic')
        paths = {}
        for monitor, info in self.monitors.items():
            path_src = self.get_path(monitor)
            path_dst = self.get_temp_path(monitor)
            paths[path_src] = path_dst

            img = Image.open(path_src)
            text = str(monitor)

            text_img = Image.new('RGBA', (400, 400), (0, 0, 0, 0))
            draw = ImageDraw.Draw(text_img)
            textsize = draw.textsize(text, font=font)
            position = [(text_img.size[i] - textsize[i]) // 2 for i in (0,1)]
            draw.text(position, text, font=font, fill='#000000')

            blurred_text_img = text_img.filter(ImageFilter.BLUR)
            ImageDraw.Draw(blurred_text_img).text(position, text, font=font, fill='#ffffff')

            img.paste(blurred_text_img, tuple((img.size[i] - blurred_text_img.size[i]) // 2 for i in (0,1)), blurred_text_img)
            img.save(path_dst, 'JPEG', quality=100)

        self.render(sorted(paths.values()))
        time.sleep(1)
        self.refresh()
        for path in paths.values():
            os.unlink(path)

    def render(self, paths):
        subprocess.Popen(['feh', '--bg-fill'] + list(paths)).wait()

    def refresh(self):
        self.render([self.get_path(i) for i in self.monitors])

def main():
    wc = WallpaperChanger()

    parser = argparse.ArgumentParser(description='Wallpaper utility')
    subparsers = parser.add_subparsers(help='chooses the subcommand')

    parser_set = subparsers.add_parser('set', help='sets a wallpaper')
    parser_set.add_argument('-p', '--preview', action='store_true', help='previews the changes without applying them')
    parser_set.add_argument('-s', '--scale', choices=['fit', 'cover', 'none'], help='selects wallpaper scale method')
    parser_set.add_argument('-c', '--color', default='#000000', help='selects background color')
    parser_set.add_argument('monitor', type=int, help='monitor number')
    parser_set.add_argument('path', help='input image path')
    parser_set.set_defaults(func=wc.set)

    parser_identify = subparsers.add_parser('identify', help='identifies monitor numbers')
    parser_identify.set_defaults(func=wc.identify)

    parser_swap = subparsers.add_parser('swap', help='swaps wallpapers between monitors')
    parser_swap.add_argument('first_monitor', nargs='?', type=int, help='first monitor number', default=1)
    parser_swap.add_argument('second_monitor', nargs='?', type=int, help='second monitor number', default=2)
    parser_swap.set_defaults(func=wc.swap)

    result = parser.parse_args()
    if 'func' not in result:
        wc.refresh()
    else:
        result.func(result)

if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print(e)
