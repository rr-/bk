#!/usr/bin/python3
from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageOps
import argparse
import hashlib
import os
import shutil
import subprocess
import sys
import tempfile
import time

class Monitor(object):
    x = 0
    y = 0
    width = 0
    height = 0

    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height

    def __repr__(self):
        return 'monitor(%dx%d+%d+%d)' % (self.width, self.height, self.x, self.y)

def run_powershell(cmd):
    ps = subprocess.Popen(['powershell', '-command', ';'.join(cmd)], stdout=subprocess.PIPE)
    return ps.stdout.read().decode('utf-8')

def get_monitors():
    if 'cygwin' in sys.platform:
        import json
        ps_cmd = [
            'Add-Type -AssemblyName System.Windows.Forms',
            '[System.Windows.Forms.Screen]::AllScreens|ConvertTo-Json'
        ]
        bounds = [m['Bounds'] for m in json.loads(run_powershell(ps_cmd))]
        return [Monitor(b['X'], b['Y'], b['Width'], b['Height']) for b in bounds]
    else:
        import ctypes
        import ctypes.util

        def load_library(name):
            path = ctypes.util.find_library(name)
            if not path:
                raise ImportError('Could not load ' + name)
            return ctypes.cdll.LoadLibrary(path)

        class XineramaScreenInfo(ctypes.Structure):
            _fields_ = [
                ('screen_number', ctypes.c_int),
                ('x', ctypes.c_short),
                ('y', ctypes.c_short),
                ('width', ctypes.c_short),
                ('height', ctypes.c_short),
            ]

        xlib = load_library('X11')
        xlib.XOpenDisplay.argtypes = [ctypes.c_char_p]
        xlib.XOpenDisplay.restype = ctypes.POINTER(ctypes.c_void_p)
        d = xlib.XOpenDisplay(b'')
        if not d:
            raise Exception('Could not open display')

        xinerama = load_library('Xinerama')
        if not xinerama.XineramaIsActive(d):
            raise Exception('Xinerama is not active')

        number = ctypes.c_int()
        xinerama.XineramaQueryScreens.restype = ctypes.POINTER(XineramaScreenInfo)
        infos = xinerama.XineramaQueryScreens(d, ctypes.byref(number))
        infos = ctypes.cast(infos, ctypes.POINTER(XineramaScreenInfo * number.value)).contents

        return [Monitor(i.x, i.y, i.width, i.height) for i in infos]

def download(url, path):
    import urllib.request
    import ssl

    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE

    u = urllib.request.urlopen(url, context=ctx)
    meta = u.info()
    if meta.get('Content-Length') is not None:
        file_size = int(meta.get('Content-Length'))
    else:
        file_size = None
    print("Downloading %s, size = %s..." % (path, file_size))

    file_size_dl = 0
    block_sz = 8192
    with open(path, 'wb') as f:
        while True:
            buffer = u.read(block_sz)
            if not buffer:
                break

            file_size_dl += len(buffer)
            f.write(buffer)
            if file_size is not None:
                status = r"%10d  [%3.2f%%]" % (file_size_dl, file_size_dl * 100. / file_size)
            else:
                status = r"%10d" % file_size_dl
            status = status + chr(8)*(len(status)+1)
            print(status)

def cover_or_fit(img, size_dst, quality, cover=False):
    ratio_src = img.size[0] / img.size[1]
    ratio_dst = size_dst[0] / size_dst[1]
    if (ratio_dst > ratio_src) == cover:
        return img.resize((size_dst[0], int(size_dst[0] // ratio_src)), quality)
    else:
        return img.resize((int(size_dst[1] * ratio_src), size_dst[1]), quality)

def cover(img, size_dst, quality=Image.ANTIALIAS):
    return cover_or_fit(img, size_dst, quality, cover=True)

def fit(img, size_dst, quality=Image.ANTIALIAS):
    return cover_or_fit(img, size_dst, quality, cover=False)


class WallpaperChanger(object):
    def __init__(self):
        self.monitors = dict((i + 1, m) for i, m in enumerate(get_monitors()))

    def validate_monitor_number(self, number):
        if number not in self.monitors:
            raise RuntimeError('Monitor number out of range')

    def get_path(self, number):
        return os.path.expanduser('~/.wallpaper%d' % number)

    def get_temp_path(self, text='tmp'):
        hash = hashlib.md5(str(text).encode('utf-8')).hexdigest()
        return os.path.join(tempfile.gettempdir(), 'wallpaper-' + hash + '.tmp')

    def set(self, args):
        gaps = [args.gap[i] for i in (3, 0, 1, 2)] #u r d l --> l u r d
        self.validate_monitor_number(args.monitor)
        monitor_size = (self.monitors[args.monitor].width, self.monitors[args.monitor].height)
        work_area = tuple(monitor_size[i] - 2 * args.border_size - sum(gaps[2*j+i] for j in (0,1)) for i in (0,1))

        target_img = Image.new('RGB', monitor_size, args.background)

        if args.path is not None:
            if args.path.startswith('http'):
                source_path = self.get_temp_path(args.path)
                if not os.path.exists(source_path):
                    download(args.path, source_path)
            else:
                source_path = args.path
            if not os.path.exists(source_path):
                raise RuntimeError(source_path + ' does not exist')

            source_img = Image.open(source_path)
            if args.crop:
                source_img = source_img.crop(tuple(int(source_img.size[i%2] * args.crop[i]) for i in (0,1,2,3)))

            if args.fit:
                source_img = fit(source_img, work_area)
            elif args.cover:
                source_img = cover(source_img, work_area)

            source_img = source_img.resize(tuple(int(source_img.size[i] * args.scale) for i in (0,1)), Image.ANTIALIAS)

            target_position = tuple(int(gaps[i] + (work_area[i] - source_img.size[i]) * args.translate[i]) for i in (0,1))

            if args.border_size:
                source_img = ImageOps.expand(source_img, border=args.border_size, fill=args.border_color)

            target_img.paste(source_img, target_position)

        target_path = (self.get_path(args.monitor), self.get_temp_path())[args.preview]
        target_img.save(target_path, 'PNG')

        if args.preview:
            paths = [(self.get_path(m), target_path)[m == args.monitor] for m in self.monitors.keys()]
            self.render(paths)
            time.sleep(1)
        self.refresh()

    def swap(self, args):
        if args.first_monitor == args.second_monitor:
            return

        self.validate_monitor_number(args.first_monitor)
        self.validate_monitor_number(args.second_monitor)

        temp_path = self.get_temp_path()
        shutil.copy(self.get_path(args.second_monitor), temp_path)
        os.rename(self.get_path(args.first_monitor), self.get_path(args.second_monitor))
        shutil.copy(temp_path, self.get_path(args.first_monitor))
        os.unlink(temp_path)
        self.refresh()

    def identify(self, args):
        if 'cygwin' in sys.platform:
            font_path = 'C:\\windows\\fonts\\Arial.ttf'
        else:
            font_path = 'arial.ttf'
        font = ImageFont.truetype(font_path, 200, encoding='unic')
        paths = {}
        for monitor, info in self.monitors.items():
            path_src = self.get_path(monitor)
            path_dst = self.get_temp_path(monitor)
            paths[path_src] = path_dst

            img = Image.open(path_src)
            text = str(monitor)

            text_img = Image.new('RGBA', (400, 400), (0, 0, 0, 0))
            draw = ImageDraw.Draw(text_img)
            textsize = draw.textsize(text, font=font)
            position = [(text_img.size[i] - textsize[i]) // 2 for i in (0,1)]
            draw.text(position, text, font=font, fill='#000000')

            blurred_text_img = text_img.filter(ImageFilter.BLUR)
            ImageDraw.Draw(blurred_text_img).text(position, text, font=font, fill='#ffffff')

            img.paste(blurred_text_img, tuple((img.size[i] - text_img.size[i]) // 2 for i in (0,1)), blurred_text_img)
            img.save(path_dst, 'JPEG', quality=100)

        self.render(sorted(paths.values()))
        time.sleep(1)
        self.refresh()
        for path in paths.values():
            os.unlink(path)

    def render(self, paths):
        if 'cygwin' in sys.platform:
            full_path = 'C:\\windows\\temp\\wallpaper.bmp'
            total_width = max(m.x + m.width for m in self.monitors.values())
            total_height = max(m.y + m.height for m in self.monitors.values())
            full_img = Image.new('RGBA', (total_width, total_height), (0, 0, 0, 0))
            for i, monitor in enumerate(self.monitors.values()):
                sub_img = Image.open(paths[i])
                sub_img = sub_img.resize((monitor.width, monitor.height))
                full_img.paste(sub_img, (monitor.x, monitor.y))
            full_img.save(full_path)
            ps_cmd = [
                '''Add-Type @"
                    using System;
                    using System.Runtime.InteropServices;
                    using Microsoft.Win32;
                    namespace Wallpaper {
                        public class Setter {
                            public const int SetDesktopWallpaper = 20;
                            public const int UpdateIniFile = 0x01;
                            public const int SendWinIniChange = 0x02;

                            [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
                            private static extern int SystemParametersInfo(int uAction, int uParam, string lpvParam, int fuWinIni);

                            public static void SetWallpaper(string path) {
                                SystemParametersInfo(SetDesktopWallpaper, 0, path, UpdateIniFile | SendWinIniChange);
                                RegistryKey key = Registry.CurrentUser.OpenSubKey("Control Panel\\\Desktop", true);
                                key.SetValue("WallpaperStyle", "1");
                                key.SetValue("TileWallpaper", "1");
                                key.Close();
                            }
                        }
                    }''' + "\n\"@",
                    '[Wallpaper.Setter]::SetWallpaper(\'' + full_path + '\')']
            run_powershell(ps_cmd)
        else:
            subprocess.Popen(['feh', '--bg-fill'] + list(paths)).wait()

    def refresh(self):
        self.render([self.get_path(i) for i in self.monitors])

def main():
    wc = WallpaperChanger()

    fmt = lambda prog: argparse.HelpFormatter(prog, max_help_position=40, width=80)
    parser = argparse.ArgumentParser(description='Wallpaper utility', formatter_class=fmt)
    subparsers = parser.add_subparsers(help='chooses the subcommand')

    parser_set = subparsers.add_parser('set', help='sets a wallpaper', formatter_class=fmt)
    parser_set.add_argument('-p', '--preview', action='store_true', help='previews the changes without applying them')
    parser_set.add_argument('-s', '--scale', type=float, metavar='r', default=1, help='scales image by given factor')
    parser_set.add_argument('-f', '--fit', action='store_true', help='fits the image within monitor work area')
    parser_set.add_argument('-c', '--cover', action='store_true', help='makes the image cover whole monitor work area')
    parser_set.add_argument('-b', '--background', metavar='c', default='#000000', help='selects background color')
    parser_set.add_argument('-t', '--translate', type=float, nargs=2, metavar=('x', 'y'), default=(0.5, 0.5), help='places the image at given position')
    parser_set.add_argument('-g', '--gap', type=int, nargs=4, metavar=('u', 'r', 'd', 'l'), default=(0, 0, 0, 0), help='keeps "border" around work area')
    parser_set.add_argument('-bs', '--border-size', type=int, metavar='s', default=0, help='selects border width')
    parser_set.add_argument('-bc', '--border-color', metavar='c', default='black', help='selects border size')
    parser_set.add_argument('--crop', type=float, nargs=4, metavar=('x1', 'y1', 'x2', 'y2'), default=(0, 0, 1, 1), help='selects crop area')
    parser_set.add_argument('monitor', type=int, help='monitor number')
    parser_set.add_argument('path', nargs='?', help='input image path')
    parser_set.set_defaults(func=wc.set)

    parser_identify = subparsers.add_parser('identify', help='identifies monitor numbers')
    parser_identify.set_defaults(func=wc.identify)

    parser_swap = subparsers.add_parser('swap', help='swaps wallpapers between monitors')
    parser_swap.add_argument('first_monitor', type=int, nargs='?', default=1, help='first monitor number')
    parser_swap.add_argument('second_monitor', type=int, nargs='?', default=2, help='second monitor number')
    parser_swap.set_defaults(func=wc.swap)

    result = parser.parse_args()
    if 'func' not in result:
        wc.refresh()
    else:
        result.func(result)

if __name__ == '__main__':
    main()
