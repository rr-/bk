#!/usr/bin/python3
from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageChops
import argparse
import os
import shutil
import subprocess
import sys
import time

def get_monitors():
    import ctypes
    import ctypes.util

    def load_library(name):
        path = ctypes.util.find_library(name)
        if not path:
            raise ImportError('Could not load ' + name)
        return ctypes.cdll.LoadLibrary(path)

    class XineramaScreenInfo(ctypes.Structure):
        _fields_ = [
            ('screen_number', ctypes.c_int),
            ('x', ctypes.c_short),
            ('y', ctypes.c_short),
            ('width', ctypes.c_short),
            ('height', ctypes.c_short),
        ]

    xlib = load_library('X11')
    xlib.XOpenDisplay.argtypes = [ctypes.c_char_p]
    xlib.XOpenDisplay.restype = ctypes.POINTER(ctypes.c_void_p)
    d = xlib.XOpenDisplay(b'')
    if not d:
        raise Exception('Could not open display')

    xinerama = load_library('Xinerama')
    if not xinerama.XineramaIsActive(d):
        raise Exception('Xinerama is not active')

    number = ctypes.c_int()
    xinerama.XineramaQueryScreens.restype = ctypes.POINTER(XineramaScreenInfo)
    infos = xinerama.XineramaQueryScreens(d, ctypes.byref(number))
    infos = ctypes.cast(infos, ctypes.POINTER(XineramaScreenInfo * number.value)).contents

    return infos

def cover_or_fit(img, size_dst, quality, cover=False):
    ratio_src = img.size[0] / img.size[1]
    ratio_dst = size_dst[0] / size_dst[1]

    if (ratio_dst > ratio_src) == cover:
        img = img.resize((size_dst[0], int(size_dst[0] // ratio_src)), quality)
        box = (0, (img.size[1] - size_dst[1]) // 2, img.size[0], (img.size[1] + size_dst[1]) // 2)
    else:
        img = img.resize((int(size_dst[1] * ratio_src), size_dst[1]), quality)
        box = ((img.size[0] - size_dst[0]) // 2, 0, (img.size[0] + size_dst[0]) // 2, img.size[1])
    return img.crop(box)

def cover(img, size_dst, quality=Image.ANTIALIAS):
    return cover_or_fit(img, size_dst, quality, cover=True)

def fit(img, size_dst, quality=Image.ANTIALIAS):
    return cover_or_fit(img, size_dst, quality, cover=False)


class WallpaperChanger(object):
    def __init__(self):
        self.monitors = dict((i + 1, m) for i, m in enumerate(get_monitors()))

    def validate_monitor_number(self, number):
        if number not in self.monitors:
            raise RuntimeError('Monitor number out of range')

    def get_path(self, number):
        return os.path.expanduser('~/.wallpaper%d' % number)

    def get_temp_path(self, number=0):
        return os.path.expanduser('~/.wallpaper%d-tmp' % number)

    def set(self, number, args):
        self.validate_monitor_number(number)

        parser = argparse.ArgumentParser(description='Sets a wallpaper.')
        parser.add_argument('-p', '--preview', action='store_true', help='previews the changes without applying them.')
        parser.add_argument('-s', '--scale', choices=['fit', 'cover', 'none'], help='selects wallpaper scale method.')
        parser.add_argument('path', nargs=1, help='selects input path.')
        result = parser.parse_args(args)
        result.path = result.path[0]

        if os.path.exists(result.path):
            img = Image.open(result.path)
        else:
            raise RuntimeError(result.path + ' does not exist')

        if result.scale == 'fit' or result.scale == None:
            img = fit(img, (self.monitors[number].width, self.monitors[number].height))
        elif result.scale == 'cover':
            img = cover(img, (self.monitors[number].width, self.monitors[number].height))

        target_path = self.get_path(number)
        if result.preview:
            target_path = self.get_temp_path()

        img.save(target_path, 'PNG')

        if result.preview:
            paths = [(self.get_path(m), target_path)[m == number] for m in self.monitors.keys()]
            self.render(paths)
            time.sleep(1)
        self.refresh()

    def swap(self, first=1, second=2):
        if first == second:
            return

        self.validate_monitor_number(first)
        self.validate_monitor_number(second)

        temp_path = self.get_temp_path()
        os.rename(self.get_path(second), temp_path)
        os.rename(self.get_path(first), self.get_path(second))
        os.rename(temp_path, self.get_path(first))
        self.refresh()

    def identify(self):
        font = ImageFont.truetype('arial.ttf', 200, encoding='unic')
        paths = {}
        for monitor, info in self.monitors.items():
            path_src = self.get_path(monitor)
            path_dst = self.get_temp_path(monitor)
            paths[path_src] = path_dst

            img = Image.open(path_src)
            text = str(monitor)

            text_img = Image.new('RGBA', (400, 400), (0, 0, 0, 0))
            draw = ImageDraw.Draw(text_img)
            textsize = draw.textsize(text, font=font)
            position = [(text_img.size[i] - textsize[i]) // 2 for i in (0,1)]
            draw.text(position, text, font=font, fill='#000000')

            blurred_text_img = text_img.filter(ImageFilter.BLUR)
            ImageDraw.Draw(blurred_text_img).text(position, text, font=font, fill='#ffffff')

            img.paste(blurred_text_img, tuple((img.size[i] - blurred_text_img.size[i]) // 2 for i in (0,1)), blurred_text_img)
            img.save(path_dst, 'JPEG', quality=100)

        self.render(sorted(paths.values()))
        time.sleep(1)
        self.refresh()
        for path in paths.values():
            os.unlink(path)

    def render(self, paths):
        subprocess.Popen(['feh', '--bg-fill'] + list(paths)).wait()

    def refresh(self):
        self.render([self.get_path(i) for i in self.monitors])

def main():
    wc = WallpaperChanger()
    if len(sys.argv) == 1:
        wc.refresh()
    else:
        try:
            if sys.argv[1] == 'set':
                which = int(sys.argv[2])
                wc.set(which, sys.argv[3:])
            elif sys.argv[1] == 'swap':
                first = 1
                second = 2
                if len(sys.argv) > 2:
                    first = int(sys.argv[2])
                if len(sys.argv) > 3:
                    second = int(sys.argv[3])
                wc.swap(first, second)
            elif sys.argv[1] == 'identify':
                wc.identify()
            else:
                raise RuntimeError('Unknown option: ' + sys.argv[1])
        except IndexError:
            print('Bad argument', file=sys.stderr)

if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print(e)
